# 최적화, 게임, 그래픽스, 파이프라인, 프로파일링, 메모리, 코드 아키텍처, 물리, UI, 오디오

## GPU
그래픽 처리를 위한 고성능의 처리장치로 그래픽카드의 핵심이다. 주로 영상정보를 처리하고 화면에 출력시키는 일을 한다.

## CPU
컴퓨터의 정중앙에서 모든 데이터를 처리하는 장치

## 유니티의 메모리
Unity에서 작성하는 스크립트는 자동 메모리 관리를 사용한다. <br>
C,C++와 같은 low level은 수동 메모리 할당을 사용하고, 프로그래머가 직접 메모리 주소에 접근해 읽고 쓰는 것을 허용하므로 모든 오브젝트 관리는 프로그래머의 책임이다.

## 가비지 콜렉터
Unity가 레퍼런스를 참조하지 못하는 오브젝트(아무것도 상속받지 않은 클래스의 인스턴스를 레퍼하는 변수를 null로 설정하면 Unity가 레퍼런스를 참조하지 못한다.) 이 오브젝트에 접근하거나 다시볼 수 없지만
메모리에는 남아있기에 C# 처럼 `managed`언어는 시간이 지나면 가비지 컬렉터가 메모리의 각 블럭에 대한 레퍼런스의 수를 내부적으로 계속 추적하여 제거해준다.

## 클래스와 구조체 차이
힙에 할당된 원본 Class를 가리키는 `레퍼런스(참조)`를 받게 되고 class에 변경이 있을 경우 class가 레퍼런스가 되는 모든 곳에서 이 변경된 내용을 볼 수 있다.

구조체는 `복사본`을 넘겨받는다. 구조체는 힙에 할당되지 않고 가비지 컬렉션의 대상이 되지도 않는다. 구조체의 복사본이 수정되어도 다른 구조체에는 영향을 주지 않는다. 장시간 유지되어야 하는
오브젝트는 클래스여야 하고, 단시간만 사용할 오브젝트는 구조체여야 한다. Vector3는 구조체다.

구조체와 클래스는 동일한 데이터여도 클래스는 참조를 위해 `8~24`바이트의 추가적인 메모리를 필요로 한다.

## 스크립트 최적화
### Instantiate, Destroy는 비용이 상당히 크다.
프리팹 수가 많다면 시작 전 미리 생성 후 `오브젝트 풀`을 활용하자.

### 나눗셈보다 곱셈을 사용하자.
나눗셈은 곱셈보다 연산속도가 월등히 느리다. `1/10` 대신 `x0.1f` 를 사용하자.

### 때로는 Update 함수보다는 Coroutine을 사용하는게 좋다.
Update는 어떠한 경우에서도 매 프레임 확인하지만 Coroutine의 경우는 원하는 순간에 잠들어 있게 할 수 있으므로 매 프레임마다 필수적으로 해야하는 작업이 아니라면 코루틴을 고려하도록 하자.
짧은 주기로 코루틴을 자주 실행한다면 `StartCoroutine()`은 Coroutine타입의 객체를 리턴하기 때문에 GC의 먹이가 되므로 아주 가끔 반복적으로 실행되는게 아니라면 대부분은 Update에서 처리한다.

### 복잡한 수학적 연산은 자제하자.
`초월함수(pow, exp, log, cos, sin, tan)`는 리소스가 상당히 많이 소요되므로 가능한 경우 사용하지 않아야 한다.

### 오브젝트의 자식이 많다면 transform 변경시 많은 비용이 발생한다. 콜백 함수가 비어있다면 지우자!
Start, Update 등 콜백함수는 비어있어도 호출이 되기 때문에 콜백함수 안에 코드가 없다면 지우자.

### GetComponent(), Find() 사용 줄이기
GetComponent, Find 류 메소드는 자주 호출하면 성능에 악영향을 끼치기에 객체 참조가 필요할 때마다 Update에서 호출하는 방식은 지양하고, 최대한 Awake, Start 메소드에서 Get, Find
메소드를 이용해서 객체들을 필드에 캐싱하여 사용해야 한다.
```C#
private Transform cachedTransform
{
  get 
  {
    if (cachedTransform == null)
    {
      cachedTransform = GetComponent<Transform>();
    }
    return cachedTransform;
  }
}
```

### 코루틴 yield 캐싱하기
코루틴은 WaitForSeconds() 등의 객체를 yield return으로 사용하는데 wait할 때마다 `new`로 동적생성할 경우, 전부 GC의 대상이 되므로 아래처럼 캐싱하여 사용하자.
```C#
private IEnumerator Coroutine()
{
  var wfs = new WaitForSeconds(1f);
  while(true)
  {
    yield return wfs;
  }
}
```
### 참조 캐싱하기
```C#
void Update()
{
  _ = Camera.main.gameObject;
  _ = Camera.main.transform.forward;
}
```
주로 프로퍼티 호출에 해당한다. 프로퍼티는 필드가 아니고 메소드처럼 사용할 수 있는 참조다. 그만큼 `메소드 호출만큼의 오버헤드가 발생`한다. 프로퍼티가 연계되어 이어진다면
각각 전부 오버헤드로 이어진다. 따라서 이를 자주 호출할 경우 미리 참조로 필드에 캐싱하여 사용하는 것이 좋다. 심지어 `Time.deltaTime`마저도 하나의 업데이트에서 여러 군데에서 사용
한다면 Update() 최상단에 캐싱하여 사용하는 것이 좋다.

### Transform 변경은 한번에 하자!
position, rotatation, scale 을 한 메소드 내에서 여러 번 변경하면 그 때마다 transform 의 변경이 이루어진다. 그런데 transform이 여러 자식 transform 가지고 있다면 자식 transform
역시 함께 변경된다. 벡터로 미리 담아두고 최종 계산 이후, 트랜스폼에 단 한번 변경을 지정하는 것이 좋다. 또한 position과 rotation을 모두 변경해야 한다면 `SetPositionAndRotation()`
메소드를 사용하는 것이 좋다.

### ScriptableObject
스크립트 내에서 항상 공통적인 변수를 사용하는 경우, 각 객체의 필드로 사용하면 동일한 데이터가 객체의 수의 배수만큼 메모리를 차지한다. 반면에 ScriptableObject로 만들고 이를 필드로
공유하면 객체의 수에 관계없이 동일 데이터는 하나만 존재하므로 메모리를 절약할 수 있다. 추가적으로 `Flyweight` 방법도 있다.

### Debug.Log 는 랩핑해서 사용하자.
디버깅할 때 도움이 되지만 빌드 이후에도 호출되면 성능을 많이 소모하므로 빌드 직전 코드를 다 지워주자.

### 박싱, 언박싱 피하자.
`박싱` 값 형식을 참조 형식으로 바꾸는 것, `언박싱` 참조 형식에서 값 형식으로 바뀌는 것을 말한다. 박싱을 하면 단순 참조보다 20배까지 시간이 소요되며, 언박싱은 할당에 4배 정도다.
이를 피할 수 있는 대표적인 방법이 바로 `제너릭`이다. 제너릭은 객체 생성, 메소드 호출 시 제너릭 타입(하나의 타입)으로 고정되기에 박싱과 언박싱을 피할 수 있다.

## 가비지 컬렉터
### 태그 비교는 CompareTag() 사용하기
객체의 tag 프로퍼티를 호출하는 것은 복사를 하여 메모리를 추가 할당하게 되므로 지양하자.

### 모든 비교문에서는 .equals()를 사용하자
`==`구문은 사용하면 암시적인 메모리가 나오게 되어 가비지 컬렉션의 먹이를 주므로 지양하자.

### foreach 대신에 for문을 사용하자.
foreach는 한 번 반복시 `24byte`의 가비지 메모리를 생성하여 수없이 돌면 더 많은 메모리를 생성시키므로 for문을 이용하자.

## 물리 성능 최적화
### Fixed Timestep 조절
Fixed Tiemstep 설정을 조정하여 물리 업데이트에 드는 시간을 줄일 수 있다. 줄이게 되면 CPU 오버헤드가 늘어나고 물리 정확도가 상승하지만, 늘리면 물리 정확도는 떨어지는 대신에 성능은
향상된다.

### Maximum Allowed Timestep
시스템에 부하가 걸려 지정된 시간보다 오래 걸릴 경우 물리 계산을 건너 뛰는 설정이다. `8~10`fps 범위로 설정하여 최악의 시나리오를 막도록 한다.

### Mesh Collider 지양
mesh Collider는 기본 콜라이더에 비해 퍼포먼스 오버헤드가 크므로 꼭 필요한 경우에만 사용해야 된다.

### Raycast, SpareCheck와 같이 충돌 감지 요소를 최소화하자.

### 움직이지 않는 배경 오브젝트는 StaticObject로 처리한다.
다만 StaticObject로 처리하였는데 중간에 움직인다면 매우 많은 비용이 들게 된다.









